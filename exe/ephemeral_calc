#!/usr/bin/env ruby


require 'ephemeral_calc'


class App

  def help
    help_text = <<eos
Usage:
    ephemeral_calc <command> <arguments>

Commands:

  beacon:
    beacon <ik> <scaler> <beacon_initial_time_seconds> <service_initial_time_seconds>

    Given the identity key, the beacon rotation exponent, and the times of
    registration for the beacon and the service, this computes the eid that the
    beacon is currently broadcasting.

  track:
    track <ik> <scaler> <beacon_initial_time_seconds> <service_initial_time_seconds>

    Given the identity key, the beacon rotation exponent, and the times of
    registration for the beacon and the service, this displays the current eid and
    outputs new eids as they are calculated, until the user presses <ctrl-c>.

  eid:
    ephemeral_calc eid <identity_key_hex> <rotation_scaler> <beacon_time_seconds>

    Generates an EID from the given 16-bytes identity key, the scaler and the
    beacon time in seconds.

  keygen:
    ephemeral_calc keygen

    Generates a curve25519 keypair

  time:
    ephemeral_calc time <identity_key_hex> <rotation_scaler> <search_start_time> <desired_eid> <max_iterations>(optional)

    Searches ahead and behind of <search_start_time> in 2**<rotation_scalar> increments for an EID matching
    the one provided. Search will look ahead and behind 100 iterations (or <max_iterations> if provided)
eos
    puts help_text
  end

  COMMANDS = [:beacon, :track, :eid, :keygen, :time]

  def beacon(track = false)
    identity_key = ARGV.shift
    rotation_scalar = ARGV.shift.to_i
    beacon_initial_time = ARGV.shift.to_i
    service_initial_time = ARGV.shift.to_i
    beacon_time_zero = Time.at( service_initial_time - beacon_initial_time)
    encryptor = EphemeralCalc::Encryptor.new identity_key, rotation_scalar, beacon_time_zero
    beacon_time = encryptor.beacon_time
    current_eid = encryptor.get_identifier
    previous_eid = encryptor.get_identifier(beacon_time - 2**rotation_scalar)
    next_eid = encryptor.get_identifier(beacon_time + 2**rotation_scalar)

    if !track
      puts "Previous EID: #{previous_eid}"
      puts " Current EID: #{current_eid}"
      puts "    Next EID: #{next_eid}"
    else
      puts "Press <ctrl-c> to stop"
      begin
        encryptor.each_identifier do |eid|
          puts "Quantum: #{encryptor.quantum}, EID: #{eid}"
        end
      rescue SignalException => e
        # ignore CTRL-C, just exit
      end
    end
  end

  def track
    beacon(true)
  end

  def eid
    identity_key = ARGV.shift
    rotation_scalar = ARGV.shift.to_i
    beacon_time = (ARGV.shift || 0).to_i
    encryptor = EphemeralCalc::Encryptor.new identity_key, rotation_scalar
    quantum = beacon_time / 2**rotation_scalar
    eid = encryptor.get_identifier(beacon_time)
    puts "Identity Key: #{identity_key}"
    puts " Beacon Time: #{beacon_time}"
    puts "     Quantum: #{quantum}"
    puts "Ephemeral ID: #{eid}"
  end

  def keygen
    key_pair = EphemeralCalc::KeyPair.new
    puts "Private Key: #{to_hex(key_pair.private_key)}"
    puts " Public Key: #{to_hex(key_pair.public_key)}"
  end

  def time
    identity_key = ARGV.shift
    rotation_scalar = ARGV.shift.to_i
    search_start_time = ARGV.shift.to_i
    desired_eid = ARGV.shift
    max_iterations = (ARGV.shift || 100).to_i
    eid_time = nil
    (0..max_iterations).each do |iteration|
      nearest_scalar_time = (search_start_time / (2**rotation_scalar)) * 2**rotation_scalar
      search_time_up = nearest_scalar_time + iteration*(2**rotation_scalar)
      search_time_down = nearest_scalar_time - iteration*(2**rotation_scalar)

      encryptor = EphemeralCalc::Encryptor.new identity_key, rotation_scalar

      candidate_eid = encryptor.get_identifier(search_time_up)
      if candidate_eid == desired_eid
        eid_time = search_time_up
        break
      end

      candidate_eid = encryptor.get_identifier(search_time_down) unless iteration == 0
      if candidate_eid == desired_eid
        eid_time = search_time_down
        break
      end
    end

    no_match_message = "No matching EID found"
    quantum_message = eid_time ? eid_time/2**rotation_scalar : no_match_message
    puts "Identity Key: #{identity_key}"
    puts " Beacon Time: #{eid_time || no_match_message}"
    puts "     Quantum: #{quantum_message}"
    puts "Ephemeral ID: #{desired_eid}"
  end

  def to_hex(bytes)
    bytes.unpack("H*")[0].upcase
  end
end

app = App.new
command = ARGV.shift

if command && App::COMMANDS.include?(command.to_sym)
  app.send(command)
else
  app.help
end
