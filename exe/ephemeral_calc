#!/usr/bin/env ruby


require 'ephemeral_calc'

class App

  def help
    help_text = <<eos
Usage:
    ephemeral_calc <command> <arguments>

Commands:

  beacon:
    ephemeral_calc beacon <ik> <scaler> <beacon_initial_time_seconds> <service_initial_time_seconds>

    Given the identity key, the beacon rotation exponent, and the times of
    registration for the beacon and the service, this computes the eid that the
    beacon is currently broadcasting.

  track:
    ephemeral_calc track <ik> <scaler> <beacon_initial_time_seconds> <service_initial_time_seconds>

    Given the identity key, the beacon rotation exponent, and the times of
    registration for the beacon and the service, this displays the current eid and
    outputs new eids as they are calculated, until the user presses <ctrl-c>.

  eid:
    ephemeral_calc eid <identity_key_hex> <rotation_scaler> <beacon_time_seconds>

    Generates an EID from the given 16-bytes identity key, the scaler and the
    beacon time in seconds.

  list:
    ephemeral_calc list <identity_key_hex> <rotation_scaler> <beacon_time_seconds> <count>

    Lists <count> EIDs, starting at <beacon_time_seconds>

  resolve:
    ephemeral_calc resolve <api_key> <eid_hex>

    Resolves the given EID to a beacon contained in Google's Proximity Beacon API.  You must supply an
    api key connected to the google project which contains the beacon.

  eidparams:
    ephemeral_calc eid_params

    Gets the EID registration parameters from Google's Proximity Beacon API. Uses environment
    variables "GOOGLE_CLIENT_ID" and "GOOGLE_CLIENT_SECRET" to do the necessary OAuth in order to
    access the API.

  register:
    ephemeral_calc register <beacon_public_key> <rotation_scaler> <initial_eid> <initial_clock> <namespace> <instance>

    Registers an EID beacon with Google's Proximity Beacon API. All keys and byte strings should be in hex.
    Uses environment variables "GOOGLE_CLIENT_ID" and "GOOGLE_CLIENT_SECRET" to do the necessary OAuth in
    order to access the API.

  keygen:
    ephemeral_calc keygen

    Generates a curve25519 keypair
eos
    puts help_text
  end

  COMMANDS = [:beacon, :track, :eid, :list, :resolve, :keygen, :eidparams, :register]

  def beacon(track = false)
    identity_key = ARGV.shift
    rotation_scalar = ARGV.shift.to_i
    beacon_initial_time = ARGV.shift.to_i
    service_initial_time = ARGV.shift.to_i
    beacon_time_zero = Time.at( service_initial_time - beacon_initial_time)
    encryptor = EphemeralCalc::Encryptor.new identity_key, rotation_scalar, beacon_time_zero
    beacon_time = encryptor.beacon_time
    current_eid = encryptor.get_identifier
    previous_eid = encryptor.get_identifier(beacon_time - 2**rotation_scalar)
    next_eid = encryptor.get_identifier(beacon_time + 2**rotation_scalar)

    if !track
      puts "Previous EID: #{previous_eid}" if previous_eid
      puts " Current EID: #{current_eid}"
      puts "    Next EID: #{next_eid}"
    else
      puts "Press <ctrl-c> to stop"
      begin
        encryptor.each_identifier do |eid|
          puts "Quantum: #{encryptor.quantum}, EID: #{eid}"
        end
      rescue SignalException => e
        # ignore CTRL-C, just exit
      end
    end
  end

  def track
    beacon(true)
  end

  def eid
    identity_key = ARGV.shift
    rotation_scalar = ARGV.shift.to_i
    beacon_time = (ARGV.shift || 0).to_i
    encryptor = EphemeralCalc::Encryptor.new identity_key, rotation_scalar
    quantum = beacon_time / 2**rotation_scalar
    eid = encryptor.get_identifier(beacon_time)
    puts "Identity Key: #{identity_key}"
    puts " Beacon Time: #{beacon_time}"
    puts "     Quantum: #{quantum}"
    puts "Ephemeral ID: #{eid}"
  end

  def list
    identity_key = ARGV.shift
    rotation_scalar = ARGV.shift.to_i
    beacon_time = ARGV.shift.to_i
    count = ARGV.shift.to_i
    encryptor = EphemeralCalc::Encryptor.new identity_key, rotation_scalar
    start_quantum = beacon_time / 2**rotation_scalar
    end_quantum = start_quantum + count - 1
    start_quantum.upto(end_quantum) do |quantum|
      start_time = quantum * 2**rotation_scalar
      end_time = start_time + 2**rotation_scalar
      eid = encryptor.get_identifier(start_time)
      puts "EID: #{eid}, Quantum: #{quantum} (#{seconds_display(start_time)} - #{seconds_display(end_time)})"
    end
  end

  def resolve
    require 'yaml'
    api_key = ARGV.shift
    eid_hex = ARGV.shift
    response = EphemeralCalc::GoogleResolver.resolve api_key, eid_hex
    if response == nil
      puts "Does not resolve!"
    else
      puts response.to_yaml
    end
  end

  def eidparams
    require 'yaml'
    eidparams = EphemeralCalc::GoogleAPI::Client.new.get_eidparams
    key_hex = to_hex(Base64.decode64(eidparams["serviceEcdhPublicKey"]))
    eidparams["serviceEcdhPublicKeyHex"] = key_hex
    puts eidparams.to_yaml
  end

  def to_hex(bytes)
    bytes.unpack("H*")[0].upcase
  end

  def from_hex(hex)
    [hex].pack("H*")
  end

  def register
    require 'yaml'
    beacon_public_key = from_hex(ARGV.shift)
    rotation_scaler = ARGV.shift
    initial_eid = from_hex(ARGV.shift)
    initial_clock = ARGV.shift
    namespace = from_hex(ARGV.shift)
    instance = from_hex(ARGV.shift)
    uid_bytes = namespace + instance
    client = EphemeralCalc::GoogleAPI::Client.new
    response = client.register_eid(beacon_public_key, rotation_scaler, initial_eid, initial_clock, uid_bytes)
    puts response.to_yaml
  end

  def keygen
    key_pair = EphemeralCalc::KeyPair.new
    puts "Private Key: #{to_hex(key_pair.private_key)}"
    puts " Public Key: #{to_hex(key_pair.public_key)}"
  end

  def seconds_display(seconds)
    case
    when seconds >= 86400
      "#{seconds / 86400}d " + seconds_display(seconds % 86400)
    when seconds >= 3600
      "#{seconds / 3600}h " + seconds_display(seconds % 3600)
    when seconds >= 60
      "#{seconds / 60}m " + seconds_display(seconds % 60)
    else
      "#{seconds}s"
    end
  end
end

app = App.new
command = ARGV.shift

if command && App::COMMANDS.include?(command.to_sym)
  app.send(command)
else
  app.help
end
