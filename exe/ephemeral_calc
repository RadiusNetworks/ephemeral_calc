#!/usr/bin/env ruby


require 'ephemeral_calc'


class App

  def help
    help_text = <<eos
Usage:
    ephemeral_calc <command> <arguments>

Commands:

  beacon:
    beacon <ik> <scaler> <beacon_initial_time_seconds> <service_initial_time_seconds>

    Given the identity key, the beacon rotation exponent, and the times of
    registration for the beacon and the service, this computes the eid that the
    beacon is currently broadcasting.

  track:
    track <ik> <scaler> <beacon_initial_time_seconds> <service_initial_time_seconds>

    Given the identity key, the beacon rotation exponent, and the times of
    registration for the beacon and the service, this displays the current eid and
    outputs new eids as they are calculated, until the user presses <ctrl-c>.

  eid:
    ephemeral_calc eid <identity_key_hex> <rotation_scaler> <beacon_time_seconds>

    Generates an EID from the given 16-bytes identity key, the scaler and the
    beacon time in seconds.

  keygen:
    ephemeral_calc keygen

    Generates a curve25519 keypair
eos
    puts help_text
  end

  COMMANDS = [:beacon, :track, :eid, :keygen]

  def beacon(track = false)
    identity_key = ARGV.shift
    rotation_scalar = ARGV.shift.to_i
    beacon_initial_time = ARGV.shift.to_i
    service_initial_time = ARGV.shift.to_i
    beacon_time_zero = Time.at( service_initial_time - beacon_initial_time)
    encryptor = EphemeralCalc::Encryptor.new identity_key, rotation_scalar, beacon_time_zero
    beacon_time = encryptor.beacon_time
    current_eid = encryptor.get_identifier
    previous_eid = encryptor.get_identifier(beacon_time - 2**rotation_scalar)
    next_eid = encryptor.get_identifier(beacon_time + 2**rotation_scalar)

    if !track
      puts "Previous EID: #{previous_eid}"
      puts " Current EID: #{current_eid}"
      puts "    Next EID: #{next_eid}"
    else
      puts "Press <ctrl-c> to stop"
      begin
        encryptor.each_identifier do |eid|
          puts "Quantum: #{encryptor.quantum}, EID: #{eid}"
        end
      rescue SignalException => e
        # ignore CTRL-C, just exit
      end
    end
  end

  def track
    beacon(true)
  end

  def eid
    identity_key = ARGV.shift
    rotation_scalar = ARGV.shift.to_i
    beacon_time = (ARGV.shift || 0).to_i
    encryptor = EphemeralCalc::Encryptor.new identity_key, rotation_scalar
    quantum = beacon_time / 2**rotation_scalar
    eid = encryptor.get_identifier(beacon_time)
    puts "Identity Key: #{identity_key}"
    puts " Beacon Time: #{beacon_time}"
    puts "     Quantum: #{quantum}"
    puts "Ephemeral ID: #{eid}"
  end

  def keygen
    key_pair = EphemeralCalc::KeyPair.new
    puts "Private Key: #{to_hex(key_pair.private_key)}"
    puts " Public Key: #{to_hex(key_pair.public_key)}"
  end

  def to_hex(bytes)
    bytes.unpack("H*")[0].upcase
  end
end

app = App.new
command = ARGV.shift

if command && App::COMMANDS.include?(command.to_sym)
  app.send(command)
else
  app.help
end
